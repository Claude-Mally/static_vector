#pragma once

#include <iostream>
#include <stdexcept>
#include <algorithm>
#include <initializer_list>

/// @brief toy example generated by ChatGPT
template <typename T, std::size_t max_capacity>
class static_vector {
public:
    static_vector() : size_(0) {}

    // Constructor with initializer list
    static_vector(std::initializer_list<T> init) {
        size_ = std::min(init.size(), max_capacity);
        std::copy(init.begin(), init.begin() + size_, data_);
    }

    // Copy constructor
    static_vector(const static_vector& other) {
        size_ = other.size_;
        std::copy(other.data_, other.data_ + size_, data_);
    }

    // Copy assignment operator
    static_vector& operator=(const static_vector& other) {
        if (this != &other) {
            size_ = other.size_;
            std::copy(other.data_, other.data_ + size_, data_);
        }
        return *this;
    }

    // Move constructor
    static_vector(static_vector&& other) {
        if (this != &other) {
            if (other.size_ > max_capacity) {
                throw std::overflow_error("Move constructor: Source capacity exceeds maximum.");
            }
            size_ = other.size_;
            std::copy(std::make_move_iterator(other.data_), std::make_move_iterator(other.data_ + size_), data_);
            other.size_ = 0;
        }
    }

    // Move assignment operator
    static_vector& operator=(static_vector&& other) {
        if (this != &other) {
            if (other.size_ > max_capacity) {
                throw std::overflow_error("Move assignment: Source capacity exceeds maximum.");
            }
            size_ = other.size_;
            std::copy(std::make_move_iterator(other.data_), std::make_move_iterator(other.data_ + size_), data_);
            other.size_ = 0;
        }
        return *this;
    }

    void push_back(const T& value) {
        if (size_ >= max_capacity) {
            throw std::overflow_error("Vector reached its maximum capacity.");
        }
        data_[size_++] = value;
    }

    void pop_back() {
        if (size_ == 0) {
            throw std::underflow_error("Vector is empty.");
        }
        --size_;
    }

    T& operator[](std::size_t index) {
        if (index >= size_) {
            throw std::out_of_range("Index out of range.");
        }
        return data_[index];
    }

    const T& operator[](std::size_t index) const {
        if (index >= size_) {
            throw std::out_of_range("Index out of range.");
        }
        return data_[index];
    }

    std::size_t size() const {
        return size_;
    }

    bool empty() const {
        return size_ == 0;
    }

    void clear() {
        size_ = 0;
    }

    void reserve(std::size_t new_capacity) {
        if (new_capacity > max_capacity) {
            throw std::overflow_error("Requested capacity exceeds maximum.");
        }
        // Capacity is fixed, no need to do anything.
    }

    // Iterator class
    class iterator {
    public:
        using iterator_category = std::forward_iterator_tag;
        using value_type = T;
        using difference_type = std::ptrdiff_t;
        using pointer = T*;
        using reference = T&;

        iterator(pointer ptr) : ptr_(ptr) {}

        reference operator*() const {
            return *ptr_;
        }

        iterator& operator++() {
            ++ptr_;
            return *this;
        }

        iterator operator++(int) {
            iterator temp = *this;
            ++ptr_;
            return temp;
        }

        bool operator==(const iterator& other) const {
            return ptr_ == other.ptr_;
        }

        bool operator!=(const iterator& other) const {
            return ptr_ != other.ptr_;
        }

    private:
        pointer ptr_;
    };

    iterator begin() {
        return iterator(data_);
    }

    iterator end() {
        return iterator(data_ + size_);
    }

private:
    T data_[max_capacity];
    std::size_t size_;
};
